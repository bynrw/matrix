# Programmierrichtlinien & Styleguide fÃ¼r React & Material UI

## 1. Einleitung

Dieses Dokument definiert die Programmierrichtlinien, Best Practices und den Code-Stil fÃ¼r unser Frontend-Projekt. Ziel ist es, eine konsistente, wartbare und qualitativ hochwertige Codebasis zu schaffen. Die Einhaltung dieser Richtlinien ist fÃ¼r alle Entwickler im Projekt verbindlich.

**Technologie-Stack:**
*   **Sprache:** JavaScript
*   **UI-Bibliothek:** React
*   **UI-Framework:** Material UI

---

## 2. Projektstruktur und Architektur

Eine klare und konsistente Projektstruktur ist entscheidend fÃ¼r die Skalierbarkeit und Wartbarkeit der Anwendung.

### 2.1 Empfohlene Ordnerstruktur

Wir verwenden eine feature-orientierte Struktur, bei der zusammengehÃ¶rige Dateien (Komponenten, Hooks, Styles) in einem Ordner gebÃ¼ndelt werden, ergÃ¤nzt durch globale Verzeichnisse.

```
/src
â”œâ”€â”€ api/                # API-Layer, Endpunkt-Definitionen, Fetch-Logik
â”œâ”€â”€ assets/             # Statische Dateien (Bilder, SVGs, Schriftarten)
â”œâ”€â”€ components/         # Globale, wiederverwendbare Komponenten (Button, Input, etc.)
â”‚   â””â”€â”€ Button/
â”‚       â”œâ”€â”€ Button.jsx
â”‚       â”œâ”€â”€ Button.test.jsx
â”‚       â””â”€â”€ index.js
â”œâ”€â”€ hooks/              # Globale, wiederverwendbare React-Hooks (z.B. useAuth, useApi)
â”œâ”€â”€ layouts/            # Layout-Komponenten (z.B. MainLayout, AuthLayout)
â”œâ”€â”€ pages/              # Seiten-Komponenten, die Routen entsprechen
â”‚   â””â”€â”€ DashboardPage/
â”‚       â”œâ”€â”€ DashboardPage.jsx
â”‚       â””â”€â”€ components/   # Spezifische Unterkomponenten nur fÃ¼r diese Seite
â”‚           â””â”€â”€ StatsCard.jsx
â”œâ”€â”€ providers/          # React Context Provider (zB. AuthProvider, ThemeProvider)
â”œâ”€â”€ routes/             # Routing-Konfiguration
â”œâ”€â”€ theme/              # MUI Theme-Konfiguration
â”‚   â”œâ”€â”€ palette.js
â”‚   â”œâ”€â”€ typography.js
â”‚   â”œâ”€â”€ components.js     # Globale MUI-Komponenten-Overrides
â”‚   â””â”€â”€ index.js          # Haupt-Theme-Datei (createTheme)
â”œâ”€â”€ utils/              # Hilfsfunktionen (Formatierer, Validatoren etc.)
â””â”€â”€ App.jsx             # Haupt-App-Komponente
```

### 2.2 Namenskonventionen fÃ¼r Dateien und Verzeichnisse

*   **Verzeichnisse:** `kebab-case` (z.B. `auth-page`). FÃ¼r Komponentenordner `PascalCase` (z.B. `UserProfile`).
*   **Komponenten:** `PascalCase` (z.B. `UserProfile.jsx`).
*   **Hooks:** `use`-PrÃ¤fix in `camelCase` (z.B. `useUserData.js`). `use` gefolgt von `PascalCase` fÃ¼r den Hook-Namen selbst (z.B. `useUserProfile`).
*   **Hilfsfunktionen & Services:** `camelCase` (z.B. `dateFormatter.js`).
*   **Testdateien:** `*.test.jsx` (z.B. `UserProfile.test.jsx`).

---

## 3. Code Style-Regeln (JavaScript + React)

Wir verwenden **Prettier** fÃ¼r die automatische Formatierung und **ESLint** zur Sicherstellung der Code-QualitÃ¤t.

### 3.1 Formatierung (durch Prettier erzwungen)

*   **EinrÃ¼ckung:** 2 Leerzeichen.
*   **ZeilenlÃ¤nge:** Maximal 100 Zeichen.
*   **Semikolons:** Immer am Zeilenende verwenden.
*   **AnfÃ¼hrungszeichen:** Single Quotes (`'`) fÃ¼r Strings.
*   **Klammern:** Immer bei `if`, `for`, `while` etc. verwenden, auch wenn der Block nur eine Zeile hat.
*   **Leerzeichen:** Um Operatoren herum (`a + b`) und innerhalb von Destrukturierungen (`{ user }` statt `{user}`).

### 3.2 Benennungskonventionen

*   **Variablen & Funktionen:** `camelCase` (z.B. `const userName = 'Burak';`).
*   **Konstanten:** `UPPER_CASE` fÃ¼r globale, unverÃ¤nderliche Werte (z.B. `const API_URL = '...';`).
*   **React-Komponenten:** `PascalCase` (z.B. `function UserProfile() {}`).
*   **Props:** `camelCase` (z.B. `<UserProfile userName="Burak" />`).
*   **Boolean Props:** Sollten einen `is`, `has`, `should` oder `can` PrÃ¤fix haben (z.B. `isOpen`, `hasError`).
*   **Event-Handler Props:** `on`-PrÃ¤fix gefolgt vom Event (z.B. `onClick`, `onInputChange`).
*   **Hooks:** `use` gefolgt von `PascalCase` (z.B. `useUserProfile`).

**Gutes Beispiel:**
```jsx
// Komponente in PascalCase, Props in camelCase
const UserList = ({ users, onUserSelect }) => {
  // Hook-Name use + PascalCase
  const useUserSelection = () => { /*...*/ };
  // ...
};
```

**Schlechtes Beispiel:**
```jsx
// Falsche Benennung fÃ¼r Komponente und Props
const user_list = (props) => {
  const { on_user_select } = props;
  // ...
};
```

### 3.3 Kommentare und JSDoc

Jede nicht-triviale Funktion, jeder Hook und jede Komponente sollte mit JSDoc kommentiert werden.

**Beispiel:**
```jsx
// Einzelzeilenkommentar fÃ¼r kurze ErklÃ¤rungen
const taxRate = 0.19;

/**
 * Summiert zwei Zahlen und gibt das Ergebnis zurÃ¼ck.
 * @param {number} a Die erste Zahl.
 * @param {number} b Die zweite Zahl.
 * @returns {number} Die Summe von a und b.
 */
function sum(a, b) {
  return a + b;
}
```

### 3.4 Guter vs. Schlechter Stil

**Schlecht ðŸ‘Ž:**
```jsx
// Harte Lesbarkeit, inkonsistente Benennung und Formatierung
const userprofile = (props) => {
    const [v, sV] = useState(false);
    if(props.user.isAdmin==true)
        return <div>Admin</div>;
    return <div onClick={() => { sV(!v) }}>{props.user.name}</div>
}
```

**Gut ðŸ‘:**
```jsx
import { useState } from 'react';

/**
 * Zeigt das Profil eines Benutzers an.
 * @param {object} props
 * @param {object} props.user - Das Benutzerobjekt.
 */
function UserProfile({ user }) {
  const [isVisible, setIsVisible] = useState(false);

  const handleToggleVisibility = () => {
    setIsVisible((prevIsVisible) => !prevIsVisible);
  };

  if (user.isAdmin) {
    return <div>Admin-Ansicht</div>;
  }

  return (
    <div onClick={handleToggleVisibility}>
      {user.name}
      {isVisible && <p>{user.email}</p>}
    </div>
  );
}
```

---

## 4. React Best Practices

### 4.1 Funktionsbasierte Komponenten

Alle neuen Komponenten **mÃ¼ssen** funktionsbasierte Komponenten mit Hooks sein. Klassenkomponenten sind veraltet und dÃ¼rfen nicht verwendet werden.

### 4.2 Grundlegende Komponente mit State

Eine einfache Komponente zeigt die grundlegende Verwendung von Funktionskomponenten und dem `useState`-Hook.

```jsx
import React, { useState } from 'react';

/**
 * Ein einfacher ZÃ¤hler, der bei jedem Klick hochzÃ¤hlt.
 */
function Counter() {
  const [count, setCount] = useState(0);

  return (
    <button onClick={() => setCount(count + 1)}>
      ZÃ¤hler: {count}
    </button>
  );
}
```

### 4.3 Wichtige Hooks

*   **`useState`:** FÃ¼r einfachen Komponenten-State.
*   **`useEffect`:** Nur fÃ¼r Seiteneffekte (API-Aufrufe, Subscriptions). Den Dependency-Array immer korrekt angeben.
*   **`useContext`:** FÃ¼r den Zugriff auf globale Daten (Theme, Authentifizierung).
*   **`useMemo`:** Um teure Berechnungen zu memoizen.
*   **`useCallback`:** Um Funktionsreferenzen zu memoizen, die an Kindkomponenten weitergegeben werden.

### 4.4 Props-Handling und Datenfluss

*   **Einweg-Datenfluss:** Daten flieÃŸen von oben nach unten (Parent zu Child).
*   **Props Destructuring:** Props immer im Funktionskopf destrukturieren.
*   **Nur notwendige Props:** Eine Komponente sollte nur die Props erhalten, die sie wirklich benÃ¶tigt.
*   **Lift State Up:** Wenn mehrere Kindkomponenten den gleichen Zustand benÃ¶tigen, hebe diesen Zustand auf die niedrigste gemeinsame Elternkomponente. Die Kinder erhalten den Zustand und die Update-Funktionen als Props.
*   **`propTypes`:** Alle Komponenten mÃ¼ssen `propTypes` definieren.

**Beispiel fÃ¼r `propTypes`:**
```jsx
import PropTypes from 'prop-types';

function UserAvatar({ imageUrl, size = 60 }) {
  return <img src={imageUrl} alt="User Avatar" width={size} height={size} />;
}

UserAvatar.propTypes = {
  imageUrl: PropTypes.string.isRequired,
  size: PropTypes.number,
};
```

### 4.5 Asynchroner Code

FÃ¼r API-Aufrufe sollte ein zentralisierter Hook (`useApi`) oder eine Service-Schicht verwendet werden, um Logik fÃ¼r Loading-Status, Fehlerbehandlung und Caching zu bÃ¼ndeln.

**Beispiel `useEffect` fÃ¼r Datenabruf:**
```jsx
function UserData({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    setLoading(true);
    setError(null);

    fetch(`/api/users/${userId}`)
      .then((res) => res.ok ? res.json() : Promise.reject('Fehler beim Laden'))
      .then((data) => setUser(data))
      .catch((err) => setError(err))
      .finally(() => setLoading(false));

  }, [userId]);

  if (loading) return <p>Lade...</p>;
  if (error) return <p>Fehler: {error}</p>;

  return <div>{user?.name}</div>;
}
```

---

## 5. Material UI (MUI) Richtlinien

### 5.1 ThemeProvider und `createTheme`

Die gesamte Anwendung muss von einem `ThemeProvider` umschlossen sein, der ein mit `createTheme` erstelltes, zentrales Theme-Objekt bereitstellt.

**`/src/theme/index.js`:**
```jsx
import { createTheme } from '@mui/material/styles';
import palette from './palette';
import typography from './typography';

const theme = createTheme({
  palette,
  typography,
  // Weitere globale Anpassungen...
});

export default theme;
```

**`/src/App.jsx`:**
```jsx
import { ThemeProvider } from '@mui/material/styles';
import theme from './theme';

function App() {
  return (
    <ThemeProvider theme={theme}>
      {/* Rest der App */}
    </ThemeProvider>
  );
}
```

### 5.2 `sx`-Prop vs. `styled()`

*   **`sx`-Prop:** Verwenden fÃ¼r einmalige, komponentenspezifische Anpassungen. Ideal fÃ¼r schnelle Layout-Anpassungen (Margin, Padding, etc.). Bietet direkten Zugriff auf Theme-Werte.
*   **`styled()`-API:** Verwenden fÃ¼r die Erstellung wiederverwendbarer, stark angepasster Komponenten. Dies ist der bevorzugte Weg, um die Basis-MUI-Komponenten zu erweitern und eine eigene Komponentenbibliothek aufzubauen.

**Beispiel `sx`:**
```jsx
<Button
  variant="contained"
  sx={{
    mt: 2, // theme.spacing(2)
    bgcolor: 'primary.dark',
    '&:hover': {
      bgcolor: 'primary.main',
    },
  }}
>
  Senden
</Button>
```

**Beispiel `styled()`:**
```jsx
import { styled } from '@mui/material/styles';
import Button from '@mui/material/Button';

const PrimaryActionButton = styled(Button)(({ theme }) => ({
  backgroundColor: theme.palette.primary.dark,
  color: theme.palette.common.white,
  padding: theme.spacing(1, 4),
  '&:hover': {
    backgroundColor: theme.palette.primary.main,
  },
}));

// Verwendung:
// <PrimaryActionButton>Jetzt Kaufen</PrimaryActionButton>
```

### 5.3 Responsives Design

*   **Grid:** Das `Grid`-System ist fÃ¼r Makro-Layouts zu bevorzugen.
*   **Breakpoints:** Verwende Breakpoints aus dem Theme, um responsive Styles zu definieren. Dies kann sowohl in der `sx`-Prop als auch in `styled()` erfolgen.

**Beispiel:**
```jsx
<Box
  sx={{
    width: {
      xs: 100, // 100px breit auf extra-small Screens
      sm: 200, // 200px breit ab small Screens
      md: 300, // etc.
    },
    bgcolor: 'secondary.main',
  }}
/>
```

### 5.4 Accessibility (a11y)

MUI bietet von Haus aus eine gute Basis fÃ¼r Barrierefreiheit. Achte darauf, diese nicht zu untergraben:
*   Gib `aria-label` fÃ¼r `IconButton`-Komponenten an.
*   Verwende `DialogTitle`, `DialogContentText` fÃ¼r korrekte Semantik in Dialogen.
*   Stelle sicher, dass alle interaktiven Elemente per Tastatur erreichbar und bedienbar sind.

---

## 6. Testing & CodequalitÃ¤t

### 6.1 Linting (ESLint + Prettier)

Jeder Commit wird durch Linter-Regeln geprÃ¼ft, um eine konsistente Code-QualitÃ¤t und -Formatierung sicherzustellen. ESLint ist fÃ¼r die Code-QualitÃ¤t (z. B. ungenutzte Variablen) und Prettier fÃ¼r die reine Code-Formatierung (EinrÃ¼ckung, ZeilenumbrÃ¼che) zustÃ¤ndig.

**`.eslintrc.js` (Beispiel mit Kommentaren):**

Diese Datei konfiguriert ESLint. Sie legt fest, welche Regeln fÃ¼r unseren Code gelten und in welcher Umgebung er ausgefÃ¼hrt wird.

```javascript
module.exports = {
  // Definiert die globalen Variablen, die in der Umgebung verfÃ¼gbar sind.
  env: {
    browser: true, // Globale Variablen des Browsers (z.B. `window`, `document`).
    es2021: true,  // Aktiviert ES2021-Syntax und globale Variablen.
    jest: true,    // Globale Variablen fÃ¼r Jest-Tests (z.B. `describe`, `it`, `expect`).
  },
  
  // Erweitert die Konfiguration um vordefinierte Regelwerke.
  // Die Reihenfolge ist wichtig: spÃ¤tere Konfigurationen Ã¼berschreiben frÃ¼here.
  extends: [
    // Aktiviert die von ESLint empfohlenen Basisregeln.
    'eslint:recommended',
    
    // Aktiviert empfohlene Regeln fÃ¼r React-Anwendungen (z.B. fehlende Keys in Listen).
    'plugin:react/recommended',
    
    // Erzwingt die "Rules of Hooks" (z.B. Hooks nur auf oberster Ebene aufrufen).
    'plugin:react-hooks/recommended',
    
    // Integriert Prettier und deaktiviert alle ESLint-Formatierungsregeln,
    // die mit Prettier in Konflikt stehen kÃ¶nnten. So wird sichergestellt,
    // dass Prettier allein fÃ¼r die Formatierung zustÃ¤ndig ist.
    // Wichtig: Muss immer der letzte Eintrag im `extends`-Array sein!
    'prettier',
  ],

  // Hier kÃ¶nnen individuelle Regeln Ã¼berschrieben oder hinzugefÃ¼gt werden.
  rules: {
    // Stuft fehlende prop-types von einem Fehler ('error') zu einer Warnung ('warn') herab.
    // Dies verhindert, dass der Build-Prozess bei fehlenden prop-types abbricht, gibt aber dennoch einen Hinweis.
    'react/prop-types': 'warn',
    
    // Deaktiviert die Regel, die `import React from 'react'` in jeder JSX-Datei erfordert.
    // Ab React 17 ist dies dank des neuen JSX-Transforms nicht mehr notwendig.
    'react/react-in-jsx-scope': 'off',
  },
  
  // Konfigurations-Einstellungen fÃ¼r Plugins.
  settings: {
    react: {
      // Weist das React-Plugin an, die installierte React-Version automatisch zu erkennen.
      // Dies ist wichtig, damit die Regeln korrekt auf die jeweilige Version angewendet werden.
      version: 'detect',
    },
  },
};
```

**`.prettierrc` (Beispiel mit Kommentaren):**

Diese Datei konfiguriert Prettier. Sie enthÃ¤lt ausschlieÃŸlich Regeln zur Code-Formatierung.

```json
{
  // `true`: FÃ¼gt am Ende jeder Anweisung ein Semikolon ein.
  // Beispiel: `const a = 1;`
  "semi": true,
  
  // `true`: Verwendet einfache AnfÃ¼hrungszeichen ('') anstelle von doppelten ("").
  // Beispiel: `const name = 'React';`
  "singleQuote": true,
  
  // FÃ¼gt ein Komma nach dem letzten Element in mehrzeiligen Objekten und Arrays hinzu.
  // 'all': FÃ¼gt es auch bei Funktionsargumenten hinzu.
  // Vorteil: Sauberere Git-Diffs, wenn neue Elemente hinzugefÃ¼gt werden.
  "trailingComma": "all",
  
  // Die maximale ZeilenlÃ¤nge, bevor Prettier einen Zeilenumbruch erzwingt.
  // Wir halten uns an die zuvor definierte Regel von 100 Zeichen.
  "printWidth": 100,
  
  // Die Anzahl der Leerzeichen pro EinrÃ¼ckungsebene.
  "tabWidth": 2
}
```

### 6.2 Komponententests (Jest + React Testing Library)

Jede Komponente sollte getestet werden.

*   **Snapshot-Tests:** Nur fÃ¼r rein statische Komponenten verwenden, um unbeabsichtigte UI-Ã„nderungen zu erkennen.
*   **Unit-Tests:** Der Fokus liegt auf der Interaktion des Benutzers. Teste, was der Benutzer sieht und tun kann, nicht die Implementierungsdetails.

**Beispiel fÃ¼r einen Komponententest (`Button.test.jsx`):**
```jsx
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom';
import Button from './Button';

describe('Button Komponente', () => {
  test('rendert den Text korrekt', () => {
    render(<Button>Klick mich</Button>);
    expect(screen.getByText('Klick mich')).toBeInTheDocument();
  });

  test('ruft den onClick-Handler auf, wenn geklickt wird', () => {
    const handleClick = jest.fn();
    render(<Button onClick={handleClick}>Klick mich</Button>);

    fireEvent.click(screen.getByText('Klick mich'));

    expect(handleClick).toHaveBeenCalledTimes(1);
  });

  test('ist deaktiviert, wenn die disabled-Prop gesetzt ist', () => {
    render(<Button disabled>Klick mich</Button>);
    expect(screen.getByRole('button')).toBeDisabled();
  });
});
```

---

## 7. Performance & Sicherheit

### 7.1 Performance

*   **Code Splitting:** Nutze `React.lazy()` und `Suspense`, um Seiten oder groÃŸe Komponenten nachzuladen.

  ```jsx
  const DashboardPage = React.lazy(() => import('./pages/DashboardPage'));

  <Suspense fallback={<div>Lade...</div>}>
    <DashboardPage />
  </Suspense>
  ```
*   **Memoization:** Verwende `React.memo` fÃ¼r Komponenten, die bei gleichen Props nicht neu rendern sollen. Kombiniere es mit `useCallback` und `useMemo` im Parent, um unnÃ¶tige Re-Renders zu vermeiden.

---

## 8. AbschlieÃŸendes Beispielprojekt (Mini-Demo)

Dieses Setup zeigt das Zusammenspiel von Theme, einer benutzerdefinierten Komponente und deren Verwendung.

**1. `/src/theme/index.js` (Theme-Setup)**
```jsx
import { createTheme } from '@mui/material/styles';

const theme = createTheme({
  palette: {
    primary: {
      main: '#1976d2',
      light: '#42a5f5',
      dark: '#1565c0',
    },
    secondary: {
      main: '#dc004e',
    },
  },
  typography: {
    fontFamily: '"Roboto", "Helvetica", "Arial", sans-serif',
    h1: {
      fontSize: '2.5rem',
      fontWeight: 500,
    },
  },
});

export default theme;
```

**2. `/src/components/layout/Navbar.jsx` (Komponente)**
```jsx
import AppBar from '@mui/material/AppBar';
import Toolbar from '@mui/material/Toolbar';
import Typography from '@mui/material/Typography';
import { styled } from '@mui/material/styles';
import Button from '@mui/material/Button';

const StyledToolbar = styled(Toolbar)(({ theme }) => ({
  display: 'flex',
  justifyContent: 'space-between',
}));

const LogoText = styled(Typography)(({ theme }) => ({
  fontWeight: 'bold',
  color: theme.palette.common.white,
}));

export default function Navbar() {
  return (
    <AppBar position="static">
      <StyledToolbar>
        <LogoText variant="h6">Mein Projekt</LogoText>
        <div>
          <Button color="inherit">Home</Button>
          <Button color="inherit">About</Button>
          <Button variant="contained" color="secondary" sx={{ ml: 2 }}>
            Login
          </Button>
        </div>
      </StyledToolbar>
    </AppBar>
  );
}
```

**3. `/src/App.jsx` (ZusammenfÃ¼hrung)**
```jsx
import { ThemeProvider, CssBaseline } from '@mui/material';
import theme from './theme';
import Navbar from './components/layout/Navbar';

function App() {
  return (
    <ThemeProvider theme={theme}>
      <CssBaseline /> {/* Normalisiert CSS */}
      <Navbar />
      <main>
        {/* Hier wÃ¼rden die Seiten-Komponenten gerendert werden */}
      </main>
    </ThemeProvider>
  );
}

export default App;
```
