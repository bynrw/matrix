# React (JavaScript) und Material-UI (MUI) - Programmier- und Style-Richtlinien

## Inhaltsverzeichnis
1. [Allgemeine Prinzipien](#allgemeine-prinzipien)
2. [React Richtlinien](#react-richtlinien)
3. [Material-UI (MUI) Richtlinien](#material-ui-mui-richtlinien)
4. [Code-Struktur und Organisation](#code-struktur-und-organisation)
5. [Styling Guidelines](#styling-guidelines)
6. [Performance Best Practices](#performance-best-practices)
7. [Testing Guidelines](#testing-guidelines)

## Allgemeine Prinzipien

### Code-Qualität
- **Lesbarkeit vor Cleverness**: Schreibe Code, der einfach zu verstehen ist
- **DRY (Don't Repeat Yourself)**: Vermeide Code-Duplikation
- **SOLID Prinzipien**: Befolge die SOLID-Prinzipien der Softwareentwicklung
- **Konsistenz**: Halte dich an einheitliche Coding-Standards

### Naming Conventions
```javascript
// Komponenten: PascalCase
const UserProfile = () => {};
const NavigationBar = () => {};

// Funktionen und Variablen: camelCase
const getUserData = () => {};
const isAuthenticated = true;

// Konstanten: SCREAMING_SNAKE_CASE
const API_BASE_URL = 'https://api.example.com';
const MAX_RETRY_ATTEMPTS = 3;

// Dateien: kebab-case oder camelCase
// user-profile.jsx oder userProfile.jsx
```

## React Richtlinien

### 1. Funktionale Komponenten und Hooks

**Bevorzuge funktionale Komponenten:**
```javascript
// ✅ Gut
const UserCard = ({ user }) => {
  const [isExpanded, setIsExpanded] = useState(false);
  
  return (
    <Card>
      <CardContent>
        <Typography variant="h6">{user.name}</Typography>
      </CardContent>
    </Card>
  );
};

// ❌ Vermeide Klassenkomponenten (außer bei Error Boundaries)
class UserCard extends Component {
  // ...
}
```

### 2. Props und PropTypes

**Verwende PropTypes oder TypeScript:**
```javascript
import PropTypes from 'prop-types';

const UserCard = ({ user, onEdit, isEditable = false }) => {
  // Component logic
};

UserCard.propTypes = {
  user: PropTypes.shape({
    id: PropTypes.string.isRequired,
    name: PropTypes.string.isRequired,
    email: PropTypes.string.isRequired,
  }).isRequired,
  onEdit: PropTypes.func,
  isEditable: PropTypes.bool,
};

UserCard.defaultProps = {
  onEdit: () => {},
  isEditable: false,
};
```

### 3. State Management

**useState für lokalen State:**
```javascript
const ContactForm = () => {
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    message: ''
  });

  const handleInputChange = (field) => (event) => {
    setFormData(prev => ({
      ...prev,
      [field]: event.target.value
    }));
  };

  return (
    // Form JSX
  );
};
```

**useReducer für komplexeren State:**
```javascript
const initialState = {
  items: [],
  loading: false,
  error: null
};

const itemsReducer = (state, action) => {
  switch (action.type) {
    case 'FETCH_START':
      return { ...state, loading: true, error: null };
    case 'FETCH_SUCCESS':
      return { ...state, loading: false, items: action.payload };
    case 'FETCH_ERROR':
      return { ...state, loading: false, error: action.payload };
    default:
      return state;
  }
};

const ItemsList = () => {
  const [state, dispatch] = useReducer(itemsReducer, initialState);
  // Component logic
};
```

### 4. Effect Hooks

**Korrekte useEffect Verwendung:**
```javascript
const UserProfile = ({ userId }) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  // Effect mit Dependency Array
  useEffect(() => {
    const fetchUser = async () => {
      try {
        setLoading(true);
        const userData = await api.getUser(userId);
        setUser(userData);
      } catch (error) {
        console.error('Failed to fetch user:', error);
      } finally {
        setLoading(false);
      }
    };

    if (userId) {
      fetchUser();
    }
  }, [userId]); // Dependency Array

  // Cleanup Effect
  useEffect(() => {
    const timer = setInterval(() => {
      // Some periodic task
    }, 1000);

    return () => clearInterval(timer);
  }, []);

  if (loading) return <CircularProgress />;
  if (!user) return <Typography>User not found</Typography>;

  return <UserDisplay user={user} />;
};
```

### 5. Custom Hooks

**Erstelle wiederverwendbare Custom Hooks:**
```javascript
// hooks/useApi.js
const useApi = (url, options = {}) => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  const fetchData = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      const response = await fetch(url, options);
      const result = await response.json();
      setData(result);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }, [url, options]);

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  return { data, loading, error, refetch: fetchData };
};

// Verwendung
const UsersList = () => {
  const { data: users, loading, error } = useApi('/api/users');
  
  if (loading) return <CircularProgress />;
  if (error) return <Alert severity="error">{error}</Alert>;
  
  return (
    <List>
      {users?.map(user => (
        <UserListItem key={user.id} user={user} />
      ))}
    </List>
  );
};
```

## Material-UI (MUI) Richtlinien

### 1. Theme Setup

**Erstelle ein konsistentes Theme:**
```javascript
// theme.js
import { createTheme } from '@mui/material/styles';

const theme = createTheme({
  palette: {
    primary: {
      main: '#1976d2',
      light: '#42a5f5',
      dark: '#1565c0',
    },
    secondary: {
      main: '#dc004e',
    },
    background: {
      default: '#f5f5f5',
    },
  },
  typography: {
    fontFamily: '"Roboto", "Helvetica", "Arial", sans-serif',
    h1: {
      fontSize: '2.5rem',
      fontWeight: 500,
    },
    h2: {
      fontSize: '2rem',
      fontWeight: 500,
    },
  },
  spacing: 8, // Standard spacing unit
  shape: {
    borderRadius: 8,
  },
  components: {
    MuiButton: {
      styleOverrides: {
        root: {
          textTransform: 'none', // Keine automatische Großschreibung
          borderRadius: 8,
        },
      },
    },
    MuiCard: {
      styleOverrides: {
        root: {
          boxShadow: '0 2px 8px rgba(0,0,0,0.1)',
        },
      },
    },
  },
});

export default theme;
```

### 2. Responsive Design

**Verwende MUI's Breakpoint System:**
```javascript
import { useTheme, useMediaQuery } from '@mui/material';
import { Box, Grid, Container } from '@mui/material';

const ResponsiveLayout = () => {
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('md'));

  return (
    <Container maxWidth="lg">
      <Grid container spacing={3}>
        <Grid item xs={12} md={8}>
          <Box
            sx={{
              display: 'flex',
              flexDirection: { xs: 'column', md: 'row' },
              gap: 2,
              p: { xs: 2, md: 3 },
            }}
          >
            {/* Content */}
          </Box>
        </Grid>
        <Grid item xs={12} md={4}>
          {/* Sidebar */}
        </Grid>
      </Grid>
    </Container>
  );
};
```

### 3. Styled Components vs sx prop

**Bevorzuge sx prop für einfache Styles:**
```javascript
// ✅ Gut für einfache Styles
<Button
  sx={{
    bgcolor: 'primary.main',
    color: 'white',
    '&:hover': {
      bgcolor: 'primary.dark',
    },
    mb: 2,
  }}
>
  Click me
</Button>

// ✅ Styled Components für komplexere oder wiederverwendbare Styles
import { styled } from '@mui/material/styles';

const StyledCard = styled(Card)(({ theme }) => ({
  padding: theme.spacing(3),
  margin: theme.spacing(2, 0),
  transition: theme.transitions.create(['transform', 'box-shadow']),
  '&:hover': {
    transform: 'translateY(-2px)',
    boxShadow: theme.shadows[8],
  },
  [theme.breakpoints.down('md')]: {
    padding: theme.spacing(2),
  },
}));
```

### 4. Icon Usage

**Konsistente Icon-Verwendung:**
```javascript
import {
  Add as AddIcon,
  Edit as EditIcon,
  Delete as DeleteIcon,
  Search as SearchIcon,
} from '@mui/icons-material';

const ActionBar = ({ onAdd, onEdit, onDelete }) => (
  <Box sx={{ display: 'flex', gap: 1 }}>
    <IconButton onClick={onAdd} color="primary" aria-label="add">
      <AddIcon />
    </IconButton>
    <IconButton onClick={onEdit} color="default" aria-label="edit">
      <EditIcon />
    </IconButton>
    <IconButton onClick={onDelete} color="error" aria-label="delete">
      <DeleteIcon />
    </IconButton>
  </Box>
);
```

### 5. Form Components

**Strukturierte Formular-Implementierung:**
```javascript
import {
  TextField,
  Button,
  FormControl,
  FormHelperText,
  InputLabel,
  Select,
  MenuItem,
} from '@mui/material';

const ContactForm = () => {
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    subject: '',
    message: '',
  });
  const [errors, setErrors] = useState({});

  const validateForm = () => {
    const newErrors = {};
    
    if (!formData.name.trim()) {
      newErrors.name = 'Name ist erforderlich';
    }
    
    if (!formData.email.trim()) {
      newErrors.email = 'E-Mail ist erforderlich';
    } else if (!/\S+@\S+\.\S+/.test(formData.email)) {
      newErrors.email = 'E-Mail-Format ist ungültig';
    }
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = (event) => {
    event.preventDefault();
    if (validateForm()) {
      // Submit logic
    }
  };

  return (
    <Box component="form" onSubmit={handleSubmit} sx={{ mt: 2 }}>
      <TextField
        fullWidth
        label="Name"
        value={formData.name}
        onChange={(e) => setFormData(prev => ({ ...prev, name: e.target.value }))}
        error={!!errors.name}
        helperText={errors.name}
        margin="normal"
        required
      />
      
      <TextField
        fullWidth
        label="E-Mail"
        type="email"
        value={formData.email}
        onChange={(e) => setFormData(prev => ({ ...prev, email: e.target.value }))}
        error={!!errors.email}
        helperText={errors.email}
        margin="normal"
        required
      />
      
      <FormControl fullWidth margin="normal">
        <InputLabel>Betreff</InputLabel>
        <Select
          value={formData.subject}
          onChange={(e) => setFormData(prev => ({ ...prev, subject: e.target.value }))}
        >
          <MenuItem value="support">Support</MenuItem>
          <MenuItem value="feedback">Feedback</MenuItem>
          <MenuItem value="other">Sonstiges</MenuItem>
        </Select>
      </FormControl>
      
      <TextField
        fullWidth
        label="Nachricht"
        multiline
        rows={4}
        value={formData.message}
        onChange={(e) => setFormData(prev => ({ ...prev, message: e.target.value }))}
        margin="normal"
      />
      
      <Button
        type="submit"
        variant="contained"
        size="large"
        sx={{ mt: 2 }}
        fullWidth
      >
        Senden
      </Button>
    </Box>
  );
};
```

## Code-Struktur und Organisation

### Projekt-Struktur
```
src/
├── components/           # Wiederverwendbare Komponenten
│   ├── common/          # Allgemeine Komponenten
│   │   ├── Button/
│   │   ├── Modal/
│   │   └── Layout/
│   └── forms/           # Formular-Komponenten
├── pages/               # Seiten-Komponenten
├── hooks/               # Custom Hooks
├── utils/               # Utility-Funktionen
├── services/            # API Services
├── contexts/            # React Contexts
├── constants/           # Konstanten
├── styles/              # Global Styles und Theme
└── __tests__/           # Test-Dateien
```

### Komponentenstruktur
```javascript
// components/UserCard/UserCard.jsx
import React from 'react';
import PropTypes from 'prop-types';
import { Card, CardContent, Typography, Avatar } from '@mui/material';
import { styled } from '@mui/material/styles';

const StyledCard = styled(Card)(({ theme }) => ({
  // Styles
}));

const UserCard = ({ user, onClick }) => {
  // Component logic
  
  return (
    <StyledCard onClick={onClick}>
      {/* JSX */}
    </StyledCard>
  );
};

UserCard.propTypes = {
  // PropTypes
};

export default UserCard;
```

## Styling Guidelines

### 1. Theme-basierte Styles
```javascript
// Verwende Theme-Werte
const MyComponent = () => (
  <Box
    sx={{
      p: 2,                    // theme.spacing(2)
      bgcolor: 'primary.main', // theme.palette.primary.main
      borderRadius: 1,         // theme.shape.borderRadius
      boxShadow: 2,           // theme.shadows[2]
    }}
  >
    Content
  </Box>
);
```

### 2. Konsistente Spacing
```javascript
// Verwende das 8px Grid System
const spacing = {
  xs: 0.5, // 4px
  sm: 1,   // 8px
  md: 2,   // 16px
  lg: 3,   // 24px
  xl: 4,   // 32px
};

<Box sx={{ p: spacing.md, m: spacing.sm }}>
  Content
</Box>
```

### 3. Color Palette
```javascript
// Verwende Palette-Farben statt hardcodierte Werte
<Typography
  sx={{
    color: 'text.primary',      // Statt '#000'
    bgcolor: 'background.paper', // Statt '#fff'
  }}
>
  Text
</Typography>
```

## Performance Best Practices

### 1. Memoization
```javascript
// React.memo für Komponenten
const ExpensiveComponent = React.memo(({ data }) => {
  return <ComplexVisualization data={data} />;
});

// useMemo für schwere Berechnungen
const ProcessedData = ({ items }) => {
  const expensiveValue = useMemo(() => {
    return items.reduce((acc, item) => {
      // Schwere Berechnung
      return acc + complexCalculation(item);
    }, 0);
  }, [items]);

  return <div>{expensiveValue}</div>;
};

// useCallback für Funktionen
const ParentComponent = () => {
  const [count, setCount] = useState(0);
  
  const handleClick = useCallback(() => {
    setCount(prev => prev + 1);
  }, []);

  return <ChildComponent onClick={handleClick} />;
};
```

### 2. Lazy Loading
```javascript
// Code Splitting mit React.lazy
const LazyComponent = React.lazy(() => import('./LazyComponent'));

const App = () => (
  <Suspense fallback={<CircularProgress />}>
    <LazyComponent />
  </Suspense>
);
```

### 3. List Optimierung
```javascript
// Verwende keys für Listen
const ItemsList = ({ items }) => (
  <List>
    {items.map(item => (
      <ListItem key={item.id}>
        <ListItemText primary={item.name} />
      </ListItem>
    ))}
  </List>
);
```

## Testing Guidelines

### 1. Component Testing
```javascript
// UserCard.test.jsx
import { render, screen, fireEvent } from '@testing-library/react';
import { ThemeProvider } from '@mui/material/styles';
import theme from '../styles/theme';
import UserCard from './UserCard';

const renderWithTheme = (component) => {
  return render(
    <ThemeProvider theme={theme}>
      {component}
    </ThemeProvider>
  );
};

describe('UserCard', () => {
  const mockUser = {
    id: '1',
    name: 'John Doe',
    email: 'john@example.com',
  };

  it('renders user information correctly', () => {
    renderWithTheme(<UserCard user={mockUser} />);
    
    expect(screen.getByText('John Doe')).toBeInTheDocument();
    expect(screen.getByText('john@example.com')).toBeInTheDocument();
  });

  it('calls onClick when clicked', () => {
    const mockOnClick = jest.fn();
    renderWithTheme(<UserCard user={mockUser} onClick={mockOnClick} />);
    
    fireEvent.click(screen.getByRole('button'));
    expect(mockOnClick).toHaveBeenCalledWith(mockUser);
  });
});
```

### 2. Hook Testing
```javascript
// useApi.test.js
import { renderHook, waitFor } from '@testing-library/react';
import { useApi } from './useApi';

// Mock fetch
global.fetch = jest.fn();

describe('useApi', () => {
  beforeEach(() => {
    fetch.mockClear();
  });

  it('fetches data successfully', async () => {
    const mockData = { id: 1, name: 'Test' };
    fetch.mockResolvedValueOnce({
      ok: true,
      json: async () => mockData,
    });

    const { result } = renderHook(() => useApi('/api/test'));

    expect(result.current.loading).toBe(true);

    await waitFor(() => {
      expect(result.current.loading).toBe(false);
    });

    expect(result.current.data).toEqual(mockData);
    expect(result.current.error).toBe(null);
  });
});
```

## Code-Qualität Tools

### ESLint Konfiguration
```json
// .eslintrc.json
{
  "extends": [
    "react-app",
    "react-app/jest"
  ],
  "rules": {
    "react/prop-types": "error",
    "react/jsx-uses-react": "error",
    "react/jsx-uses-vars": "error",
    "react-hooks/rules-of-hooks": "error",
    "react-hooks/exhaustive-deps": "warn"
  }
}
```

### Prettier Konfiguration
```json
// .prettierrc
{
  "semi": true,
  "trailingComma": "es5",
  "singleQuote": true,
  "printWidth": 80,
  "tabWidth": 2
}
```

## Accessibility Guidelines

### 1. ARIA Labels und Semantic HTML
```javascript
const AccessibleButton = () => (
  <Button
    aria-label="Benutzer hinzufügen"
    aria-describedby="add-user-description"
  >
    <AddIcon />
  </Button>
);

const AccessibleForm = () => (
  <form role="form" aria-labelledby="form-title">
    <Typography id="form-title" variant="h2">
      Benutzer-Registrierung
    </Typography>
    <TextField
      label="Name"
      required
      aria-required="true"
      aria-describedby="name-helper"
    />
    <FormHelperText id="name-helper">
      Geben Sie Ihren vollständigen Namen ein
    </FormHelperText>
  </form>
);
```

### 2. Keyboard Navigation
```javascript
const KeyboardNavigable = () => {
  const handleKeyDown = (event) => {
    if (event.key === 'Enter' || event.key === ' ') {
      event.preventDefault();
      handleAction();
    }
  };

  return (
    <Box
      role="button"
      tabIndex={0}
      onKeyDown={handleKeyDown}
      onClick={handleAction}
      sx={{ cursor: 'pointer' }}
    >
      Klickbares Element
    </Box>
  );
};
```
